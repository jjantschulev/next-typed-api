import { IS_MUTATION } from '../server/handler-types';
import { RequestMethod } from '../server/typed-api';
import { BuildConfig } from './build';
import { ApiPath } from './parse-appdir';

function validateUrl(url: string | undefined, name: string) {
  if (!url) return;
  try {
    new URL(url);
  } catch {
    throw new Error(
      `${name} must be a valid origin and include a protocol and host. For example: https://example.com. Currently it is: ${url}`,
    );
  }
}

export function codegen(
  paths: ApiPath[],
  baseFolderPath: string,
  { reactQuery, overrideOrigin, serverSideOrigin }: BuildConfig,
) {
  validateUrl(overrideOrigin, 'overrideOrigin');
  validateUrl(serverSideOrigin, 'serverSideOrigin');

  const imports: string[] = [];
  const params: string[] = [];
  const asserts: string[] = [];
  const routes: Record<RequestMethod, string[]> = {
    DELETE: [],
    GET: [],
    HEAD: [],
    OPTIONS: [],
    PATCH: [],
    POST: [],
    PUT: [],
  };
  let currentIndex = 0;

  for (const path of paths) {
    const importId = `Route${currentIndex++}`;
    const importPath =
      './' + path.filepath.slice(baseFolderPath.length + 1, -3);

    const methods = Object.entries(path.methods)
      .filter(([, hasMethod]) => hasMethod)
      .map(([method]) => method as RequestMethod);

    imports.push(
      `import type { ${methods
        .map((m) => `${m} as ${importId}${m}`)
        .join(', ')} } from "${importPath}";`,
    );

    const paramsTypeArgs = Object.entries(path.params)
      .map(([param, type]) => {
        return `${param}:${type === 'string' ? 'string' : 'string[]'};`;
      })
      .join('');

    if (paramsTypeArgs.length > 0)
      params.push(`type ${importId}Params = {${paramsTypeArgs}};`);
    else params.push(`type ${importId}Params = Record<string, never>;`);

    methods.forEach((m) => {
      asserts.push(`Assert<APIType<typeof ${importId}${m}>["method"], "${m}">`);
      asserts.push(
        `Assert<APIType<typeof ${importId}${m}>["routeParams"], ${importId}Params>`,
      );

      routes[m].push(
        `'${path.url}': { api: APIType<typeof ${importId}${m}>; params: ${importId}Params; };`,
      );
    });
  }

  const routeDict = Object.entries(routes)
    .filter(([, r]) => r.length)
    .map(([method, routes]) => {
      return `type Routes${method} = {
    ${routes.join('\n    ')}
};`;
    });

  const functions = Object.entries(routes)
    .filter(([, r]) => r.length)
    .map(([method]) => {
      return `export const api${upperFirst(
        method,
      )} = makeApiRequestFunction<Routes${method}, '${method}'>('${method}', URL_CONFIG);`;
    });

  const reactQueryFunctions = reactQuery
    ? Object.entries(routes)
        .filter(([, r]) => r.length)
        .map(([method]) => {
          const mutation = `export const useApi${upperFirst(
            method,
          )}Mutation = makeUseApiMutation<Routes${method}, '${method}'>('${method}', useMutation, URL_CONFIG);`;
          if (IS_MUTATION[method as RequestMethod]) {
            return mutation;
          } else {
            const query = `export const useApi${upperFirst(
              method,
            )}Query = makeUseApiQuery<Routes${method}, '${method}'>('${method}', useQuery, URL_CONFIG);`;
            const getKeyFn = `export const getApi${upperFirst(
              method,
            )}QueryKey = makeBuildUrlFunction<Routes${method}>(URL_CONFIG);`;
            return [query, mutation, getKeyFn];
          }
        })
        .flat()
    : [];

  const typeHelpers = Object.entries(routes)
    .filter(([, r]) => r.length)
    .map(([method]) => {
      return [
        `export type TypeOf${upperFirst(
          method,
        )}<T extends keyof Routes${method}> = Routes${method}[T]['api']['data'];`,
        `export type BodyOf${upperFirst(
          method,
        )}<T extends keyof Routes${method}> = Routes${method}[T]['api']['body'];`,
        `export type ParamsOf${upperFirst(
          method,
        )}<T extends keyof Routes${method}> = Routes${method}[T]['params'];`,
        `export type QueryOf${upperFirst(
          method,
        )}<T extends keyof Routes${method}> = Routes${method}[T]['api']['queryParams'];`,
        `export type ${upperFirst(method)}Route = keyof Routes${method};`,
      ].join('\n');
    });

  const buildUrlFunctions = Object.entries(routes)
    .filter(([, r]) => r.length)
    .map(([method]) => {
      return `export const build${upperFirst(
        method,
      )}Url = makeBuildUrlFunction<Routes${method}>(URL_CONFIG);`;
    });

  return `/* eslint-disable */
  
// Do not edit this file, it is auto-generated. All changes will be lost.

import type { APIType } from "next-typed-api/client"
import { makeApiRequestFunction, makeUseApiMutation, makeUseApiQuery, makeBuildUrlFunction } from "next-typed-api/client"
${
  reactQuery
    ? `import { useMutation, useQuery } from '@tanstack/react-query';`
    : ''
}  

${imports.join('\n')}

const URL_CONFIG = {
  overrideOrigin: ${overrideOrigin ? `'${overrideOrigin}'` : 'undefined'},
  serverSideOrigin: ${serverSideOrigin ? `'${serverSideOrigin}'` : 'undefined'},
};

${params.join('\n')}

${routeDict.join('\n')}

${functions.join('\n')}

${buildUrlFunctions.join('\n')}

${reactQueryFunctions.join('\n')}

${typeHelpers.join('\n')}

type _Asserts = [
    ${asserts.join(',\n    ')}
];

type Assert<T, U extends T> = T;
`;
}

function upperFirst(str: string) {
  if (str.length === 0) return str;
  return str[0].toUpperCase() + str.slice(1).toLowerCase();
}
